# Embedding Pipeline

The Embedding Pipeline is responsible for embedding and storing documents using a specified embedding model and database. It chunks the text into manageable pieces, transforms them based on metadata, generates embeddings, and stores the embedded chunks in the database.

## Custom Embedding Pipeline

The `CustomEmbeddingPipeline` is a custom implementation of the `EmbeddingPipeline` that inherits from the `BasicEmbeddingPipeline` class. It overrides the `transform_chunks` method to include readability scoring.

```python
from r2r.pipelines import BasicEmbeddingPipeline
import textstat

class CustomEmbeddingPipeline(BasicEmbeddingPipeline):
    def __init__(
        self,
        embedding_model: str,
        embeddings_provider: OpenAIEmbeddingProvider,
        db: VectorDBProvider,
        text_splitter: TextSplitter,
        logging_connection: Optional[LoggingDatabaseConnection] = None,
        embedding_batch_size: int = 1,
        id_prefix: str = "demo",
    ):
        super().__init__(
            embedding_model,
            embeddings_provider,
            db,
            text_splitter,
            logging_connection,
            embedding_batch_size,
            id_prefix,
        )

    @log_execution_to_db
    def transform_chunks(
        self, chunks: list[str], metadatas: list[dict]
    ) -> list[str]:
        """
        Transforms text chunks based on their metadata and calculates readability scores.
        """
        transformed_chunks = []
        for chunk, metadata in zip(chunks, metadatas):
            readability_score = textstat.flesch_reading_ease(chunk)
            metadata["readability_score"] = readability_score
            transformed_chunks.append(chunk)
        return transformed_chunks
```

In this custom implementation, the `transform_chunks` method is overridden to include readability scoring logic using the `textstat` library. The readability score is added to the chunk metadata.

### Initialization

The `CustomEmbeddingPipeline` is initialized with the same parameters as the `BasicEmbeddingPipeline`.

### Pipeline Execution

The `run` method from the base class (`BasicEmbeddingPipeline`) is used to execute the embedding pipeline. It performs the necessary steps, including the modified `transform_chunks` method that includes readability scoring.

## Passing the Custom Embedding Pipeline to the Factory

To use the `CustomEmbeddingPipeline` with the `E2EPipelineFactory`, you can pass it when creating the pipeline:

```python
from r2r.main import E2EPipelineFactory
from my_custom_pipeline import CustomEmbeddingPipeline

app = E2EPipelineFactory.create_pipeline(
    config=config,
    embedding_pipeline_impl=CustomEmbeddingPipeline,
)
```

By passing the `CustomEmbeddingPipeline` to the `create_pipeline` method using the `embedding_pipeline_impl` parameter, the factory will use the custom pipeline instead of the default `BasicEmbeddingPipeline`.

That's it! You now have custom ingestion and embedding pipelines that can be passed to the `E2EPipelineFactory` for use in the end-to-end pipeline.